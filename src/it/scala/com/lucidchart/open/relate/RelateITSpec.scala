package com.lucidchart.open.relate

import com.lucidchart.open.relate.Query._
import java.sql.{DriverManager, Connection}
import org.specs2.mutable._

class RelateITSpec extends Specification {

  val url = "jdbc:mysql://localhost/"
  val dbName = "relate_it_tests"
  val driver = "com.mysql.jdbc.Driver"
  val user = "dev"
  val pass = "dev"
  implicit val connection = try {
    Class.forName(driver)
    DriverManager.getConnection(url + dbName, user, pass)
  }

  case class PokedexEntry(
    id: Long,
    name: String,
    description: String
  )

  val pokedexParser = RowParser { row =>
    PokedexEntry(
      row.long("id"),
      row.string("name"),
      row.string("description")
    )
  }

  case class Pokemon(
    id: Long,
    pokedexId: Long,
    level: Int,
    trainerId: Option[Long]
  )

  val pokemonParser = RowParser { row =>
    Pokemon(
      row.long("id"),
      row.long("pokedex_id"),
      row.int("level"),
      row.longOption("trainer_id")
    )
  }

  //check if statements all closed in all tests stmt.isClosed

  "insert" should {
    
    "work in the basic case (uses select to test)" in {
      val pokemonName = "Snorlax"
      val pokemonDesc = "a sleepy Pokemon"

      SQL("""
        INSERT INTO pokedex (name, description) VALUES ({name}, {description})
      """).on { implicit query =>
        string("name", pokemonName)
        string("description", pokemonDesc)
      }.executeInsert()

      //now check if that record was correctly inserted
      val entries = SQL("""
       SELECT id, name, description FROM pokedex WHERE name = {name}
      """).on { implicit query =>
       string("name", pokemonName)
      }.executeQuery().asList(pokedexParser)

      (entries.size must_== 1) and (entries(0).name must_== pokemonName) and (entries(0).description must_== pokemonDesc)
    }

    "work for multi-insert" in {
     val pokedexId = 8
     val records = List(
       Pokemon(-1, pokedexId, 16, Some(1L)),
       Pokemon(-1, pokedexId, 5, None),
       Pokemon(-1, pokedexId, 10, Some(2L))
     )

     SQL("""
       INSERT INTO pokemon (pokedex_id, level, trainer_id) VALUES {tuples}
     """).expand { implicit query =>
       tupled("tuples", List("id", "level", "trainer"), records.size)
     }.onTuples("tuples", records) { (pokemon, query) =>
       query.long("id", pokemon.pokedexId)
       query.int("level", pokemon.level)
       query.longOption("trainer", pokemon.trainerId)
     }.executeInsert()

     //check if those records were inserted
     val pokemon = SQL("""
       SELECT id, pokedex_id, level, trainer_id FROM pokemon WHERE pokedex_id = {pokedexId}
     """).on { implicit query =>
       long("pokedexId", pokedexId)
     }.executeQuery().asList(pokemonParser)
    
     val levelAndTrainerIdFromDb = pokemon.map { pokemon =>
       (pokemon.level, pokemon.trainerId)
     }
     val levelAndTrainerIdFromTest = records.map { pokemon =>
       (pokemon.level, pokemon.trainerId)
     }
     (pokemon.size must_== records.size) and (levelAndTrainerIdFromDb must_== levelAndTrainerIdFromTest)
    }

    "be able to retrieve an autogenerated key" in {
      val id = SQL ("""
        INSERT INTO pokedex (name, description)
        VALUES ("Charmander", "as adorable as a fire lizard can be")
      """).executeInsert.scalar[Long]
      id.isDefined must beTrue
    }

    "be able to retrieve a list of autogenerated keys" in {
      val newEntries = Array(
        PokedexEntry(-1, "Bulbasaur", "a weird leaf thing grows on its back"),
        PokedexEntry(-1, "Ivysaur", "hard to say if it's any different from Bulbasaur")
      )

      val ids = SQL("""
        INSERT INTO pokedex (name, description) VALUES {tuples}
      """).expand { implicit query =>
        tupled("tuples", List("name", "description"), newEntries.size)
      }.onTuples("tuples", newEntries) { (entry, query) =>
        query.string("name", entry.name)
        query.string("description", entry.description)
      }.executeInsert
    
      //not totally implemented yet
      false must beTrue
    }
  }

  "select" should {
    "work with asSingle (also tests retrieving null value)" in {
      val pokemon = SQL("""
        SELECT id, pokedex_id, level, trainer_id
        FROM pokemon
        WHERE id = {id}
      """).on { implicit query =>
        long("id", 7L)
      }.executeQuery().asSingle(pokemonParser)

      (pokemon.id must_== 7) and (pokemon.pokedexId must_== 4) and (pokemon.level must_== 3) and (pokemon.trainerId must_== None)
    }
    
    "work when asSingleOption should return a value" in {
      val pokemon = SQL("""
        SELECT id, pokedex_id, level, trainer_id
        FROM pokemon
        WHERE id = {id}
      """).on { implicit query =>
        long("id", 7L)
      }.executeQuery().asSingleOption(pokemonParser).get

      (pokemon.id must_== 7) and (pokemon.pokedexId must_== 4) and (pokemon.level must_== 3) and (pokemon.trainerId must_== None)
    }

    "work when asSingleOption should not return a value" in {
      val pokemon = SQL("""
        SELECT id, pokedex_id, level, trainer_id
        FROM pokemon
        WHERE id = -1
      """).executeQuery().asSingleOption(pokemonParser)
    
      pokemon must_== None
    }
    
    "work with asSet" in {
      val squirtle = PokedexEntry(1, "Squirtle", "a cute water turtle")

      val pokemon = SQL("""
        SELECT id, name, description
        FROM pokedex
        WHERE name = {name}
      """).on { implicit query =>
        string("name", squirtle.name)
      }.executeQuery().asSet(pokedexParser)

      (pokemon.size must_== 1) and (pokemon must contain(squirtle))
    }

    "work with empty asSet" in {
      val pokemon = SQL("""
        SELECT id, name, description
        FROM pokedex
        WHERE id = -1
      """).executeQuery().asSet(pokedexParser)

      pokemon.size must_== 0
    }

    "work with asSeq" in {
      val squirtle = PokedexEntry(1, "Squirtle", "a cute water turtle")
      val pikachu = PokedexEntry(4, "Pikachu", "an overrated electric mouse")
      
      val pokemon = SQL("""
        SELECT id, name, description
        FROM pokedex
        WHERE name = {name1} OR name = {name2}
      """).on { implicit query =>
        string("name1", squirtle.name)
        string("name2", pikachu.name)
      }.executeQuery().asSeq(pokedexParser)

      (pokemon.size must_== 2) and (pokemon must contain(squirtle)) and (pokemon must contain(pikachu))
    }

    "work with empty asSeq" in {
      val pokemon = SQL("""
        SELECT id, name, description
        FROM pokedex
        WHERE id = -1
      """).executeQuery().asSeq(pokedexParser)

      (pokemon.size must_== 0)
    }

    "work with asIterable" in {
      val names = Array("Wartortle", "Blastoise", "Geodude")

      val pokemon = SQL("""
        SELECT id, name, description
        FROM pokedex
        WHERE name = {name1} OR name = {name2} OR name = {name3}
      """).on { implicit query =>
        string("name1", names(0))
        string("name2", names(1))
        string("name3", names(2))
      }.executeQuery().asIterable(pokedexParser)

      val iterableAsList = pokemon.map(_.name)
      (iterableAsList must contain(names(0))) and (iterableAsList must contain(names(1))) and (iterableAsList must contain(names(2)))
    }

    "work with empty asIterable" in {
      val pokemon = SQL("""
        SELECT id, name, description
        FROM pokedex
        WHERE id = -1
      """).executeQuery().asIterable(pokedexParser).toList

      pokemon.size must_== 0
    }

    "work for asList" in {
      val jigglypuff = PokedexEntry(6, "Jigglypuff", "whoever thought Jigglypuff would be a good idea was stupid")
      val magikarp = PokedexEntry(7, "Magikarp", "some say it's worthless")
      val pokemon = SQL("""
        SELECT id, name, description
        FROM pokedex
        WHERE name = {name1} OR name = {name2}
      """).on { implicit query =>
        string("name1", jigglypuff.name)
        string("name2", magikarp.name)
      }.executeQuery().asList(pokedexParser)

      (pokemon.size must_== 2) and (pokemon must contain(jigglypuff)) and (pokemon must contain(magikarp))
    }

    "work for empty asList" in {
      val pokemon = SQL("""
        SELECT id, name, description
        FROM pokedex
        WHERE id = -1
      """).executeQuery().asList(pokedexParser)

      pokemon.size must_== 0
    }

    "work for asMap" in {
      val wartortle = PokedexEntry(2, "Wartortle", "Squirtle's more sassy evolved form")
      val blastoise = PokedexEntry(3, "Blastoise", "an awesome turtle with water cannons")
      
      val pokemon = SQL("""
        SELECT id, name, description
        FROM pokedex
        WHERE name = {name1} OR name = {name2}
      """).on { implicit query =>
        string("name1", wartortle.name)
        string("name2", blastoise.name)
      }.executeQuery().asMap(RowParser { row =>
        (row.string("name"), row.string("description"))
      })

      (pokemon(wartortle.name) must_== wartortle.description) and (pokemon(blastoise.name) must_== blastoise.description)
    }

    "work for empty asMap" in {
      val pokemon = SQL("""
        SELECT id, name, description
        FROM pokedex
        WHERE id = -1
      """).executeQuery().asMap(RowParser { row =>
        (row.string("name"), row.string("description"))
      })

      pokemon.size must_== 0
    }

    //scalar
    //scalarOption

    "work using expand for the IN clause" in {
      val ids = Array(1L, 2L, 3L)

      val pokemonNames = SQL("""
        SELECT id, name, description
        FROM pokedex
        WHERE id IN ({ids})
      """).expand { implicit query =>
        commaSeparated("ids", ids.size)
      }.on { implicit query =>
        longs("ids", ids)
      }.executeQuery().asList(pokedexParser).map(_.name)

      (pokemonNames must contain("Squirtle")) and (pokemonNames must contain("Wartortle")) and (pokemonNames must contain("Blastoise"))
    }
  }

  "update" should {
    //update matched rows
    //not update unmatched rows
  }

  "delete" should {
    //delete matched rows
    //not delete matched rows
  }

}
