package com.lucidchart.open.relate

import com.lucidchart.open.relate.Query._
import java.sql.{DriverManager, Connection}
import org.specs2.mutable._

class RelateITSpec extends Specification {

  val url = "jdbc:mysql://localhost/"
  val dbName = "relate_it_tests"
  val driver = "com.mysql.jdbc.Driver"
  val user = "dev"
  val pass = "dev"
  implicit val connection = try {
    Class.forName(driver)
    DriverManager.getConnection(url + dbName, user, pass)
  }

  case class PokedexEntry(
    id: Long,
    name: String,
    description: String
  )

  val pokedexParser = RowParser { row =>
    PokedexEntry(
      row.long("id"),
      row.string("name"),
      row.string("description")
    )
  }

  case class Pokemon(
    id: Long,
    pokedexId: Long,
    level: Int,
    trainerId: Option[Long]
  )

  val pokemonParser = RowParser { row =>
    Pokemon(
      row.long("id"),
      row.long("pokedex_id"),
      row.int("level"),
      row.longOption("trainer_id")
    )
  }

  //check if statements all closed in all tests stmt.isClosed

  "insert" should {
    
    // "work in the basic case (uses select to test)" in {
    //   val pokemonName = "Snorlax"
    //   val pokemonDesc = "a sleepy Pokemon"

    //   SQL("""
    //     INSERT INTO pokedex (name, description) VALUES ({name}, {description})
    //   """).on { implicit query =>
    //     string("name", pokemonName)
    //     string("description", pokemonDesc)
    //   }.executeInsert()

    //   //now check if that record was correctly inserted
    //   val entries = SQL("""
    //    SELECT id, name, description FROM pokedex WHERE name = {name}
    //   """).on { implicit query =>
    //    string("name", pokemonName)
    //   }.executeQuery().asList(pokedexParser)

    //   (entries.size must_== 1) and (entries(0).name must_== pokemonName) and (entries(0).name must_== entries(0))
    // }

    // "work for multi-insert" in {
    //  val pokedexId = 7
    //  val records = Array(
    //    Pokemon(-1, pokedexId, 16, Some(1L)),
    //    Pokemon(-1, pokedexId, 5, None),
    //    Pokemon(-1, pokedexId, 10, Some(2L))
    //  )

    //  SQL("""
    //    INSERT INTO pokemon (pokedex_id, level, trainer_id) VALUES {tuples}
    //  """).expand { implicit query =>
    //    tupled("tuples", List("id", "level", "trainer"), records.size)
    //  }.onTuples("tuples", records) { (pokemon, query) =>
    //    query.long("id", pokemon.pokedexId)
    //    query.int("level", pokemon.level)
    //    query.longOption("trainer", pokemon.trainerId)
    //  }.executeInsert()

    //  //check if those records were inserted
    //  val pokemon = SQL("""
    //    SELECT id, pokedex_id, level, trainer_id FROM pokemon WHERE pokedex_id = {pokedexId}
    //  """).on { implicit query =>
    //    long("pokedexId", pokedexId)
    //  }.executeQuery().asList(pokemonParser)
    
    //  val levelAndTrainerIdFromDb = pokemon.map { pokemon =>
    //    (pokemon.level, pokemon.trainerId)
    //  }
    //  val levelAndTrainerIdFromTest = records.map { pokemon =>
    //    (pokemon.level, pokemon.trainerId)
    //  }
    //  (pokemon.size must_== records.size) and (levelAndTrainerIdFromDb must_== levelAndTrainerIdFromTest)
    // }

    "be able to retrieve an autogenerated key" in {
      val id = SQL ("""
        INSERT INTO pokedex (name, description) VALUES("Charmander", "as adorable as a fire lizard can be")
      """).executeInsert.scalar[Long]
      id.isDefined must beTrue
    }

    "be able to retrieve a list of autogenerated keys" in {
      val newEntries = Array(
        PokedexEntry(-1, "Bulbasaur", "a weird leaf thing grows on its back"),
        PokedexEntry(-1, "Ivysaur", "hard to say if it's any different from Bulbasaur")
      )

      val ids = SQL("""
        INSERT INTO pokedex (name, description) VALUES {tuples}
      """).expand { implicit query =>
        tupled("tuples", List("name", "description"), newEntries.size)
      }.onTuples("tuples", newEntries) { (entry, query) =>
        query.string("name", entry.name)
        query.string("description", entry.description)
      }.executeInsert
    
      //not totally implemented yet
      false must beTrue
    }
  }

  "select" should {
    //work for all collection types
    //asSingle
    //asSingleOption
    //asSet
    //asSeq
    //asIterable
    //asList
    //asMap
    //scalar
    //scalarOption
    //work for the IN clause
  }

  "update" should {
    //update matched rows
    //not update unmatched rows
  }

  "delete" should {
    //delete matched rows
    //not delete matched rows
  }

}
