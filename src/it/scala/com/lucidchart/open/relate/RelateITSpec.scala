package com.lucidchart.open.relate

import com.lucidchart.open.relate.Query._
import java.sql.{DriverManager, Connection}
import org.specs2.mutable._

class RelateITSpec extends Specification {

  val url = "jdbc:mysql://localhost/"
  val dbName = "relate_it_tests"
  val driver = "com.mysql.jdbc.Driver"
  val user = "dev"
  val pass = "dev"
  implicit val connection = try {
    Class.forName(driver)
    DriverManager.getConnection(url + dbName, user, pass)
  }

  case class PokedexEntry(
    id: Long,
    name: String,
    description: String
  )

  val pokedexParser = RowParser { row =>
  	PokedexEntry(
  		row.long("id"),
  		row.string("name"),
  		row.string("description")
  	)
  }

  case class Pokemon(
  	id: Long,
  	pokedexId: Long,
  	level: Int,
  	trainerId: Option[Long]
  )

  val pokemonParser = RowParser { row =>
  	Pokemon(
  		row.long("id"),
  		row.long("pokedex_id"),
  		row.int("level"),
  		row.longOption("trainer_id")
  	)
  }

  //check if statements all closed in all tests stmt.isClosed

  "insert" should {
    
    "work in the basic case (uses select to test)" in {
      val pokemonName = "Snorlax"
      val pokemonDesc = "a sleepy Pokemon"

      SQL("""
        INSERT INTO pokedex (name, description) VALUES ({name}, {description})
      """).on { implicit query =>
        string("name", pokemonName)
        string("description", pokemonDesc)
      }.executeInsert()

      //now check if that record was correctly inserted
      val entries = SQL("""
      	SELECT id, name, description FROM pokedex WHERE name = {name}
      """).on { implicit query =>
      	string("name", pokemonName)
      }.executeQuery().asList(pokedexParser)

      (entries.size must_== 1) and (entries(0).name must_== pokemonName) and (entries(0).name must_== entries(0))
    }

    // "work for multi-insert" in {
    // 	val pokedexId = 7
    // 	val records = Array(
    // 		Pokemon(-1, pokedexId, 16, Some(1L)),
    // 		Pokemon(-1, pokedexId, 5, None),
    // 		Pokemon(-1, pokedexId, 10, Some(2L))
    // 	)

    // 	SQL("""
    // 		INSERT INTO pokemon (pokedex_id, level, trainer_id) VALUES {tuples}
    // 	""").expand { implicit query =>
    // 		tupled("tuples", List("id", "level", "trainer"), records.size)
    // 	}.onTuples("tuples", records) { (pokemon, query) =>
    // 		query.long("id", pokemon.pokedexId)
    // 		query.int("level", pokemon.level)
    // 		query.longOption("trainer", pokemon.trainerId)
    // 	}.executeInsert()

    // 	//check if those records were inserted
    // 	val pokemon = SQL("""
    // 		SELECT id, pokedex_id, level, trainer_id FROM pokemon WHERE pokedex_id = {pokedexId}
    // 	""").on { implicit query =>
    // 		long("pokedexId", pokedexId)
    // 	}.executeQuery().asList(pokemonParser)
    
    // 	val levelsToId
    // 	(pokemon.size must_== records.size) and (records(0).)
    // }

    //autogenerated keys
  }

  "select" should {
    //work for all collection types
    //asSingle
    //asSingleOption
    //asSet
    //asSeq
    //asIterable
    //asList
    //asMap
    //scalar
    //scalarOption
    //work for the IN clause
  }

  "update" should {
    //update matched rows
    //not update unmatched rows
  }

  "delete" should {
    //delete matched rows
    //not delete matched rows
  }

}
